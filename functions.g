LoadPackage("rig");





#############################
##                         ##
##   TECHNICAL FUNCTIONS   ##
##                         ##
#############################

### DESC: Returns true if SmallQuandle(n, x) exists, false otherwise.
### STATUS: WORKING
### NOTES: Uses the "catch error" technique. The function CALL_WITH_CATCH is undocumented — use with caution.

smallQuandleCatch := function(n, x)

	local result;

	BreakOnError := false;  # Temporarily disable breaking on errors
	result := CALL_WITH_CATCH(x -> SmallQuandle(n, x), [ x ])[1];  # Attempt to construct the quandle safely
	BreakOnError := true;   # Restore error-breaking behavior
	
	return result;  # Returns 'true' if successful, 'false' if an error occurred
	
end;





### DESC: Returns true if the SmallGroup(n, x) exists, false otherwise.
### STATUS: WORKING
### NOTES: Uses the "catch error" technique. The function CALL_WITH_CATCH is undocumented — use with caution.

smallGroupCatch := function(n, x)

	local result;

	BreakOnError := false;  # Suppress error interruptions
	result := CALL_WITH_CATCH(x -> SmallGroup(n, x), [ x ])[1];  # Try to create the group safely
	BreakOnError := true;   # Restore default error behavior

	return result;  # Returns true if successful, false if an error occurred

end;





### DESC: Relabels the entries of the rack matrix R according to a new label list l.
### STATUS: WORKING 
### NOTES: Assumes l is a list where l[i] gives the new label for original label i. It is used only for the sum of racks now, and it returns a matrix, not a rack, as RIG does not support racks with elements different from [1..n]

changeLabels := function(R, l)
	
	local S, n, i, j;
	
	n := R.size;
	S := DiagonalMat([1..n]);  # Initialize an n×n matrix with identity entries
	
	for i in [1..n] do
		for j in [1..n] do
			S[i][j] := l[R.matrix[i][j]];  # Replace each entry using the new label list
		od;
	od;
	
	return S;  # Return the relabeled matrix

end;





###################################
##                               ##
##   TECHNICAL GROUP FUNCTIONS   ##
##                               ##
###################################

### DESC: Computes the subgroup of fixed points of an automorphism a of a group G.
### STATUS: WORKING
### NOTES: 

fixedPoints := function(G, a)

	local fix, x;
	
	fix := [];  # List to store elements fixed by a
	
	for x in G do
		if x^a = x then  # Check if x is fixed under a
			Add(fix, x);
		fi;
	od;

	return Subgroup(G, fix);  # Return the subgroup generated by the fixed elements

end;





### DESC: Returns a given automorphism a of a group G in permutation form.
### STATUS: WORKING
### NOTES: 

automorphismAsPerm := function(G, a)
	
	local elts, list, x;
	
	elts := Elements(G);  # List all elements of the group G
	list := List(elts, x -> Position(elts, x^a));  # Map each element to its image under a
	
	return PermList(list);  # Return the permutation corresponding to a

end;





### DESC: Returns the cycle structure decomposition of a given permutation p in a readable form.
### STATUS: WORKING
### NOTES: 

cycleDecomposition := function(p)
	
	local cycles, l, i;
	
	cycles := CycleStructurePerm(p);  # Get list where index i stores the number of (i+1)-cycles
	l := [];  # Will hold the formatted cycle structure
	
	for i in [1..Size(cycles)] do
		if IsBound(cycles[i]) then  # Check if there are cycles of length i+1
			Add(l, Concatenation(String(i+1), "^", String(cycles[i])));  # Format as "length^count"
		fi;
	od;
	
	return l;  # Return the formatted list of cycle types

end;





### DESC: Returns the set of cycle lengths of a given permutation p in a readable form.
### STATUS: WORKING
### NOTES: 

cycleLengths := function(p)
	
	local cycles, l, i;
	
	cycles := CycleStructurePerm(p);  # Get the cycle structure: cycles[i] = number of (i+1)-cycles
	l := [];  # Will store the distinct cycle lengths
	
	for i in [1..Size(cycles)] do
		if IsBound(cycles[i]) then  # If there are cycles of length i+1
			Add(l, i+1);  # Add that cycle length
		fi;
	od;
	
	return AsSet(l);  # Return the set of cycle lengths (no duplicates)

end;





#################################
##                             ##
##   QUANDLE BASIC FUNCTIONS   ##
##                             ##
#################################

### DESC: Displays the Cayley table of a given rack in a formatted layout
### STATUS: WORKING
### NOTES: 

rackTable := function(R)

	local M, i, j, blockSize, block, k, adjustSize, header;
	
	# Helper function to right-align an item within a block of width n
	adjustSize := function(item, n)
		local i, block;

		block := "";
		# Add padding spaces to align the item to the right
		for i in [1..n - Size(String(item))] do
			block := Concatenation(block, " ");
		od;
		
		# Append the item after the padding
		block := Concatenation(block, String(item));
		
		return block;
	end;
	
	M := R.matrix;  # The Cayley table of the rack

	# Determine block size based on the length of the largest label
	blockSize := Size(String(Size(R)));
	
	# Construct the top header row
	header := "";
	block := adjustSize("", blockSize);  # Empty block for top-left corner
	block := Concatenation(block, " ");
	header := Concatenation(header, block, "| ");

	for i in [1..Size(R)] do
		block := adjustSize(String(R.labels[i]), blockSize);  # Format column labels
		block := Concatenation(block, " ");
		header := Concatenation(header, block);
	od;
	
	Print(header);
	Print("\n");
	
	# Print a horizontal separator line under the header
	for i in [1..Size(header)-1] do
		Print("-");
	od;
	Print("\n");
	
	# Print each row of the Cayley table
	for i in [1..Size(M)] do
		# Print the row label (leftmost column)
		block := adjustSize(String(R.labels[i]), blockSize);
		block := Concatenation(block, " ");
		Print(block);
		Print("| ");

		# Print the row entries
		for j in [1..Size(M)] do
			block := adjustSize(String(M[j][i]), blockSize);  # Format each table entry
			block := Concatenation(block, " ");
			Print(block);
		od;
		Print("\n");
	od;
	
end;





### DESC: Returns the list of rows of a given rack R.
### STATUS: WORKING
### NOTES: 

rackRows := function(R)

	return TransposedMat(R.matrix);  # Transpose the matrix to get rows as lists

end;





### DESC: Returns the list of columns of a given rack R.
### STATUS: WORKING
### NOTES: 

rackCols := function(R)

	return R.matrix;  # Columns are stored as rows in GAP's matrix format
	
end;





### DESC: Returns whether the given quandle Q is primitive (its inner group acts primitively).
### STATUS: WORKING
### NOTES: 

isPrimitive := function(Q)

	return IsPrimitive(InnerGroup(Q));  # Check primitivity of the inner automorphism group

end;





### DESC: Returns whether the quandle Q is isomorphic to the core of a group.
### STATUS: WORKING
### NOTES: 

isCore := function(Q)
	
	local Gs, idcores, x;

	Gs := AllSmallGroups(Size(Q));  # All groups of order equal to Q
	idcores := List(Gs, x -> IdQuandle(CoreRack(x)));  # ID list of their core quandles

	return IdQuandle(Q) in idcores;  # Check if Q matches any core quandle
	
end;





### DESC: Returns whether a connected quandle Q is affine (i.e., its transvection group is abelian).
### STATUS: WORKING
### NOTES: Returns -1 if Q is not connected.

isConnectedAffine := function(Q)

	if not IsConnected(Q) then return -1; fi;  # Early exit if not connected
	
	return IsAbelian(TransvectionsGroup(Q));  # Affine if transvection group is abelian

end;





### DESC: Returns whether a connected quandle Q is principal (i.e., point stabilizer at 1 is trivial).
### STATUS: WORKING
### NOTES: Returns -1 if Q is not connected.

isConnectedPrincipal := function(Q)

	local disPointStabilizer;

	if not IsConnected(Q) then return -1; fi;  # Early exit if not connected
	
	# Computes the stabilizer of a given point in the transvection group
	disPointStabilizer := function(Q, e)
		local G, x;
		G := TransvectionsGroup(Q);
		G := Filtered(G, x -> e^x = e);  # Elements fixing e
		return G;
	end;

	return IsTrivial(disPointStabilizer(Q, 1));  # Principal if stabilizer at 1 is trivial

end;





### DESC: Checks if a partition P is right-compatible with the structure of the quandle Q.
### STATUS: WORKING
### NOTES: A partition is "right compatible" if each class is closed under the right action of the quandle generators.

isRightCompatible := function(partition, Q)
    local class, elementIndex, targetClass, representative, j;

    for class in partition do
        for elementIndex in [1 .. Size(Q)] do

            # Find the class (targetClass) that contains the image of the element under the quandle action
            for targetClass in partition do
                if Q.matrix[class[1]][elementIndex] in targetClass then
                    break;
                fi;
            od;

            # Check that the entire class maps inside the same target class
            for j in [1 .. Size(class)] do
                if not Q.matrix[class[j]][elementIndex] in targetClass then
                    return false;
                fi;
            od;

        od;
    od;

    return true;
end;





### DESC: Returns the list of congruences of a connected quandle Q.
### STATUS: WORKING
### NOTES: 

connectedCongruences := function(Q)
    local subracks, innerGroup, blocks, compatiblePartitions, intersection, orbitPartition, i, fullPartition;

    subracks := Subracks(Q, Size(Q));            # All subracks of maximal size
    innerGroup := InnerGroup(Q);                 # Inner group of the quandle
    blocks := AllBlocks(innerGroup);             # Blocks (G-invariant partitions)
    compatiblePartitions := [];

    intersection := Intersection(subracks, blocks);  # Blocks that are also subracks

    for i in intersection do
        orbitPartition := Orbit(innerGroup, i, OnSets);  # Get the partition generated by the orbit

        if isRightCompatible(orbitPartition, Q) then
            Add(compatiblePartitions, orbitPartition);   # Add if right-compatible
        fi;
    od;

    # Add the trivial partition consisting of the single class with all elements
    fullPartition := [ [1 .. Size(Q)] ];
    Add(compatiblePartitions, fullPartition);

    return compatiblePartitions;
end;





### DESC: Given a rack R, returns all the orbits of R under the natural action of Inn(R), as a partition
### STATUS: WORKING
### NOTES:

rackOrbits := function(R)
	local orb, i;

	orb := [];
	
	for i in R.labels do
		Add(orb, Set(RackOrbit(R, i)));  # Compute orbit of element i and add as a set
	od;
	
	return List(Set(orb));  # Remove duplicates by converting to a set, then back to a list
end;





### DESC: Returns all quandles of size n.
### STATUS: WORKING
### NOTES: Uses an error-catching technique to stop when no more SmallQuandles exist.

allSmallQuandlesOfSize := function(n)
	local foundMore, index, Quandles;

	foundMore := true;
	index := 1;
	Quandles := [];
	
	while foundMore do
		if smallQuandleCatch(n, index) then
			Add(Quandles, SmallQuandle(n, index));  # Add quandle if it exists
		else
			foundMore := false;  # Stop when no quandle found
		fi;
		index := index + 1;
	od;
	
	return Quandles;
end;





### DESC: Returns all quandles of sizes given in the list l.
### STATUS: WORKING
### NOTES: 

allSmallQuandlesOfSizes := function(l)
	local i, Qs;

	Qs := [];
	
	for i in l do
		Append(Qs, allSmallQuandlesOfSize(i));  # Append all quandles of size i
	od;
	
	return Qs;
end;





### DESC: Given a rack R, returns all the subracks of R ordered by size.
### STATUS: WORKING
### NOTES:

allSubracks := function(R)
	local i, j, M, p, Q, subracks, sizes;

	subracks := [];
	sizes := [];
	
	# Collect all subracks of R for each possible size
	for i in [1 .. Size(R)] do
		Append(subracks, SubracksUpToIso(R, [i], Size(R)));
	od;
	
	# Remove duplicate subracks
	subracks := Unique(subracks);
	
	# Normalize labels in each subrack's multiplication table (matrix)
	for Q in subracks do
		p := Q.labels;
		M := Q.matrix;
		
		for i in [1 .. Size(M)] do
			for j in [1 .. Size(M)] do
				M[i][j] := p[M[i][j]];
			od;
		od;
		
		Q.Matrix := M;  # Update the matrix in the subrack object
	od;
	
	# Collect sizes of all subracks for sorting
	for i in [1 .. Size(subracks)] do
		Add(sizes, subracks[i].size);
	od;
	
	# Sort subracks by their sizes
	SortParallel(sizes, subracks);
	
	return subracks;
end;





### DESC: Returns the disjoint sum of two given racks R and S
### STATUS: WORKING
### NOTES: During the construction, the rack S is relabelled accordingly.

sumOfRacks := function(R,S)
	local M, N, T, m, n, k, i, j;

	m := R.size;
	n := S.size;
	k := m + n;
	
	M := StructuralCopy(R.matrix);
	N := changeLabels(S, [m+1 .. m+n]);
	
	T := DiagonalMat([1 .. k]);
	
	for i in [1 .. k] do
		for j in [1 .. k] do
			if (i <= m and j <= m) then
				T[i][j] := M[i][j];
			elif (m < i and m < j) then
				T[i][j] := N[i-m][j-m];
			else
				T[i][j] := j;
			fi;
		od;
	od;
	
	return Rack(T);
end;





### DESC: Returns the disjoint sum of a rack with itself n-1 times (n-fold disjoint sum).
### STATUS: WORKING
### NOTES: It uses sumOfRacks

rackMultiple := function(R,n)
	local S, i;

	S := StructuralCopy(R);
	
	for i in [1 .. n-1] do
		S := sumOfRacks(R, S);
	od;
	
	return S;
end;





### DESC: Given a rack R, returns the n-folded rack R_n.
### STATUS: WORKING
### NOTES: Applies the n-th power of each permutation in the rack to produce a folded rack.

rackFolded := function(R,n)
	local nperm, elts, M, i, f;

	nperm := List(Permutations(R), x -> x^n);
	elts := R.labels;
	M := [];
	
	for i in [1 .. Size(nperm)] do
		f := nperm[i];
		Add(M, List(elts, x -> x^f));
	od;
	
	return Rack(M);
end;






### DESC: Computes the conjugation rack (quandle) on a group G using its conjugacy class.
### STATUS: WORKING
### NOTES: The rack operation is defined by conjugation in G.

conjugationRack := function(G)
	local n, M, i, j, eltsG, p;
	
	n := Size(G);
	M := DiagonalMat([1 .. n]);
	eltsG := Elements(G);
	
	for i in [1 .. n] do
		for j in [1 .. n] do
			p := (eltsG[j]^-1) * eltsG[i] * eltsG[j];
			M[i][j] := Position(eltsG, p);
		od;
	od;
	
	return Rack(TransposedMat(M));
end;






### DESC: Computes the twisted principal rack over (G, a).
### STATUS: WORKING
### NOTES: The rack operation twists conjugation by an automorphism a.

twistedPrincipalRack := function(G,a)
	local n, M, i, j, eltsG, p;
	
	n := Size(G);
	M := DiagonalMat([1 .. n]);
	eltsG := Elements(G);
	
	for i in [1 .. n] do
		for j in [1 .. n] do
			p := eltsG[i] * (eltsG[j] * (eltsG[i]^-1))^a;
			M[i][j] := Position(eltsG, p);
		od;
	od;
	
	return Rack(M);
end;






### DESC: Takes as input a connected quandle Q and returns its profile as a string.
### STATUS: Works only for connected racks.
### NOTES: The profile describes the cycle structure of the first inner automorphism of Q.

Profile := function(Q)

	local phi, cycleStructure, profileStr, i;
	
	if not IsConnected(Q) then return -1; fi;  # Early exit if not connected

    if not IsConnected(Q) then
        Print("The rack is not connected");
        return false;
    fi;

    phi := Permutations(Q)[1];
    cycleStructure := CycleStructurePerm(phi);
    profileStr := Concatenation("(1^", String(Size(Q) - NrMovedPoints(phi)), ",");

    for i in [1 .. Size(cycleStructure)] do
        if IsBound(cycleStructure[i]) then
            profileStr := Concatenation(profileStr, String(i + 1), "^", String(cycleStructure[i]), ",");
        fi;
    od;

    profileStr[Size(profileStr)] := ')';  # Replace final comma with closing parenthesis

    return profileStr;
end;







### DESC: Tests Hayashi's Conjecture on a given connected quandle Q.
### STATUS: Works only for connected racks.
### NOTES: The test omits the 1-cycles since they are irrelevant for the conjecture.

Hayashi := function(Q)

    local phi, cycleStructure, nontrivialLengths, i;
	
	if not IsConnected(Q) then return -1; fi;  # Early exit if not connected

    phi := Permutations(Q)[1];
    cycleStructure := CycleStructurePerm(phi);
    nontrivialLengths := [];

    for i in [1 .. Size(cycleStructure)] do
        if IsBound(cycleStructure[i]) then
            Add(nontrivialLengths, i + 1);
        fi;
    od;

    for i in [1 .. Size(nontrivialLengths)] do
        if RemInt(nontrivialLengths[Size(nontrivialLengths)], nontrivialLengths[i]) <> 0 then
            return false;
        fi;
    od;

    return true;
end;






### DESC: Given a group G, an automorphism a of G, and a subgroup H < Fix(a), constructs a coset quandle Q(G,H,a)
### STATUS: WORKING
### NOTES: Works only if H is a subgroup of the fixed point subgroup of a

cosetQuandle := function(G, H, a)
    local transversal, cosetList, matrix, g, i, j, product, k;

    if not IsSubgroup(fixedPoints(G, a), H) then
        return false;
    fi;

    cosetList := [];
    transversal := RightTransversal(G, H);

    # Build the list of right cosets
    for g in transversal do
        Add(cosetList, AsSet(RightCoset(H, g)));
    od;

    matrix := DiagonalMat([1 .. Size(cosetList)]);

    # Compute the quandle operation matrix
    for i in [1 .. Size(transversal)] do
        for j in [1 .. Size(transversal)] do
            product := ((transversal[i] * transversal[j]^-1)^a) * transversal[j];
            for k in [1 .. Size(cosetList)] do
                if product in cosetList[k] then
                    matrix[i][j] := k;
                fi;
            od;
        od;
    od;

    return Rack(TransposedMat(matrix));
end;





### DESC: Returns the list of all coset quandles that can be constructed from a group G
### STATUS: WORKING
### NOTES: Tries every automorphism a and every subgroup H < Fix(a)

allCosetQuandles := function(G)
    local subgroups, subgroup, automorphisms, aut, quandles;

    automorphisms := AllAutomorphisms(G);
    quandles := [];

    for aut in automorphisms do
        subgroups := AllSubgroups(fixedPoints(G, aut));
        for subgroup in subgroups do
            Add(quandles, cosetQuandle(G, subgroup, aut));
        od;
    od;

    return quandles;
end;





### DESC: Given an element e of G, returns the position of the coset He (containing e)
### STATUS: WORKING
### NOTES:

positionOfCosetAsQuandleElement := function(G, H, e)
    local transversal, cosetList, g, i;

    cosetList := [];
    transversal := RightTransversal(G, H);

    for g in transversal do
        Add(cosetList, AsSet(RightCoset(H, g)));
    od;

    for i in [1 .. Size(transversal)] do
        if e in cosetList[i] then
            return i;
        fi;
    od;
end;





### DESC: Returns the position of the first occurrence of the element x in the matrix M
### STATUS: WORKING
### NOTES: Returns a pair [row, column] if x is found, false otherwise

positionMat := function(M, x)
    local i;

    for i in [1 .. Size(M)] do
        if x in M[i] then
            return [i, Position(M[i], x)];
        fi;
    od;

    return false;
end;






### DESC: Returns the quotient rack R/θ where θ is a congruence (as a partition of R)
### STATUS: WORKING
### NOTES: Assumes θ is a partition of R into equivalence classes

quotientRack := function(R, theta)
    local i, j, numClasses, permutationList, Qmatrix, conjugator;

    numClasses := Size(theta);                   # Number of equivalence classes
    permutationList := Permutations(R);          # Permutations of the rack R
    Qmatrix := DiagonalMat([1 .. numClasses]);   # Initialize identity matrix for quotient

    for i in [1 .. numClasses] do
        for j in [1 .. numClasses] do
            conjugator := permutationList[theta[j][1]];  # Permutation corresponding to class j
            Qmatrix[i][j] := positionMat(theta, theta[i][1]^conjugator)[1];  # Determine image class
        od;
    od;

    return Rack(Qmatrix);   # Return the quotient rack as a new rack object
end;






### DESC: Computes the congruence of a rack R generated by the generators gens (gens is a list of pairs)
### STATUS: WORKING, but slow for large racks
### NOTES: Constructs the smallest congruence containing gens via closure operations (equiv. relation generation)

rackCongruenceGeneratedBy := function(R, gens)
    local cg, con, perm, expand, i, j, k, after, before, el, Rx, Ry, Ri, x, y, copy;

    perm := Permutations(R);
    cg := gens;
    expand := Size(cg);

    # Bottom-up construction of the congruence generated by gens
    while expand > 0 do
        before := Size(cg);
        copy := ShallowCopy(cg);

        # Right multiplication and left multiplication closure
        for el in cg do
            x := el[1];
            y := el[2];
            for i in [1 .. Size(R)] do
                Rx := perm[x];
                Ry := perm[y];
                Ri := perm[i];
                Add(copy, [x^Ri, y^Ri]);   # Right action closure
                Add(copy, [i^Rx, i^Ry]);   # Left action closure
            od;
        od;

        cg := Unique(copy);
        copy := ShallowCopy(cg);

        # Symmetric closure
        for el in cg do
            Add(copy, [el[2], el[1]]);
        od;

        cg := Unique(copy);
        copy := ShallowCopy(cg);

        # Transitive closure
        for i in [1 .. Size(R)] do
            for j in [1 .. Size(R)] do
                for k in [1 .. Size(R)] do
                    if ([i, k] in cg and [k, j] in cg) then
                        Add(copy, [i, j]);
                    fi;
                od;
            od;
        od;

        cg := Unique(copy);
        after := Size(cg);
        expand := after - before;
    od;

    # Convert list of related pairs to partition format
    con := [];
    for i in [1 .. Size(R)] do
        Add(con, [i]);
    od;

    for i in [1 .. Size(R)] do
        for j in [1 .. Size(R)] do
            if [i, j] in cg then
                Add(con[i], j);
            fi;
        od;
    od;

    # Normalize and remove duplicate blocks
    for i in [1 .. Size(R)] do
        con[i] := Set(con[i]);
    od;

    con := Set(con);
    return List(con);
end;






### DESC: Computes all the principal congruences of a rack R
### STATUS: WORKING, but slow for large racks
### NOTES: Principal congruences are generated by single pairs [i, j]

allPrincipalRackCongruences := function(R)
    local con, i, j;

    con := [];

    for i in [1 .. Size(R)] do
        for j in [1 .. Size(R)] do
            Add(con, Set(rackCongruenceGeneratedBy(R, [[i, j]])));
        od;
    od;

    return Unique(con);
end;





### DESC: Given an equivalence alpha (i.e. a partition), verifies if elements x and y are in the same block
### STATUS: WORKING
### NOTES: Helper function used to test membership in an equivalence class

inRelation := function(x, y, alpha)
    local block;

    for block in alpha do
        if (x in block) and (y in block) then
            return true;
        fi;
    od;

    return false;
end;







### DESC: Returns the uniform congruences of a quandle Q in partition form
### STATUS: WORKING, too slow for large racks, outdated as the function connectedCongruences() does it better
### NOTES: For connected quandles, all congruences are uniform, so this returns all congruences in that case

uniformCongruences := function(Q)
    local divisors, elements, perms, potentialCongruences, congruences;
    local x, y, z, d, block, cong;
    local Lx, Ly, Lz, Lxmo, Lymo, Lzmo, uniformPartitions, check;

    divisors := DivisorsInt(Size(Q));
    elements := Q.labels;
    perms := Permutations(Q);

    potentialCongruences := [];
    congruences := [];

    check := true;

    # Step 1: Construct all uniform partitions of Q.labels into d blocks, for each divisor d
    for d in divisors do
        uniformPartitions := PartitionsSet(elements, d);
        uniformPartitions := Filtered(
            uniformPartitions,
            x -> Size(Set(List(x, y -> Size(y)))) = 1   # Only keep uniform partitions (equal-sized blocks)
        );
        Append(potentialCongruences, uniformPartitions);
    od;

    # Step 2: Check each candidate partition for congruence conditions
    for cong in potentialCongruences do
        for block in cong do
            for x in block do
                for y in block do
                    for z in elements do
                        Lx := perms[x];  Lxmo := Lx^-1;
                        Ly := perms[y];  Lymo := Ly^-1;
                        Lz := perms[z];  Lzmo := Lz^-1;

                        if not (inRelation(z^Lx, z^Ly, cong) and
                                inRelation(x^Lz, y^Lz, cong) and
                                inRelation(z^Lxmo, z^Lymo, cong) and
                                inRelation(x^Lzmo, y^Lzmo, cong)) then

                            check := false;
                            break;
                        fi;
                    od;

                    if check = false then break; fi;
                od;

                if check = false then break; fi;
            od;

            if check = false then break; fi;
        od;

        if check = true then
            Add(congruences, cong);
        fi;

        check := true;
    od;

    return congruences;
end;





### DESC: Checks if a partition s is less than or equal to a partition t in the refinement order
### STATUS: WORKING
### NOTES: s ≤ t if every block of s is fully contained in a block of t

IsPartitionLeq := function(s, t)
    local sMap, tMap, block, correspondingBlocks, i, element, PartitionMap;

    # Converts the partitions into maps: element -> block index
    PartitionMap := function(partition)
        local map, i, block, element;
        map := [];
        for i in [1..Length(partition)] do
            block := partition[i];
            for element in block do
                map[element] := i;
            od;
        od;
        return map;
    end;

    # Build the maps for partitions s and t
    sMap := PartitionMap(s);
    tMap := PartitionMap(t);

    # Check if every block of s is contained in a single block of t
    for block in s do
        # Find the unique block indices in t that elements of the block in s map to
        correspondingBlocks := Set(List(block, x -> tMap[x]));
        if Length(correspondingBlocks) > 1 then
            # A block in s is not contained in a single block of t
            return false;
        fi;
    od;

    # All blocks of s are contained in blocks of t
    return true;
end;




### DESC: Constructs a list of edges representing the refinement ordering among a list of partitions (parts).
### STATUS: WORKING
### NOTES: The partitions must all be over the same set; indices are incremented by 1 for output format. This is typically used to build the Hasse diagram of the congruence lattice of a rack or quandle.


partitionsToPairs := function(parts)
    local pairs, i, n, j, p;

    pairs := [];
    n := Size(parts);

    for i in [1..n] do
        Add(pairs, [0, i]);
    od;

    for i in [1..n] do
        for j in [1..n] do
            if IsPartitionLeq(parts[i], parts[j]) then
                Add(pairs, [i, j]);
            fi;
        od;
    od;

    for p in pairs do
        p[1] := p[1] + 1;
        p[2] := p[2] + 1;
    od;

    return pairs;
end;




### DESC: Checks whether the quandle Q is subdirectly irreducible (SI)
### STATUS: WORKING
### NOTES: A quandle is SI if one of its connected congruences is contained in all the others


isSI := function(Q)
    local i, j, found, s, t, partitions;

    partitions := connectedCongruences(Q);

    # Check if there exists a congruence s contained in all others
    for i in [1..Length(partitions)] do
        s := partitions[i];
        found := true;

        # Check if s is contained in every other congruence t
        for j in [1..Length(partitions)] do
            if i <> j then
                t := partitions[j];
                if not IsPartitionLeq(s, t) then
                    found := false;
                    break;
                fi;
            fi;
        od;

        # If such a minimal s exists, then Q is SI
        if found then
            return true;
        fi;
    od;

    # No congruence is contained in all others → not SI
    return false;
end;




### DESC: Returns the Hasse diagram of the lattice of connected congruences of Q, as pairs (edges)
### STATUS: WORKING
### NOTES: Nodes are indexed starting from 1

congruenceLattice := function(Q)
    return partitionsToPairs(connectedCongruences(Q));
end;





### DESC: Given a rack Q and a subset X, returns the subrack of Q generated by X.
### STATUS: WORKING
### NOTES: Iteratively computes the closure of X under the rack action until no new elements are added.

subrackGeneratedBy := function(R, set)
    
    local S, oldS, P;
    
    S := set;
    oldS := [];
    
    while Set(oldS) <> Set(S) do
        oldS := S;
        P := Group(Permutations(R){oldS});
        S := List(oldS, x -> Orbit(P, x));
        S := Unique(Flat(S));
    od;
    
    return S;
end;



### DESC: Given a set A and a positive integer c, returns all subsets of A of size c.
### STATUS: WORKING
### NOTES: Generates all unique subsets of fixed size c by iteratively building combinations.

powerSetWithCardinality := function(A, c)
    local set, sets, newsets, i, x;

    if c = 0 then
        return [[]];  # Return list containing empty set when c=0
    fi;

    if c > Size(A) then
        return [];   # No subsets possible if c > size of A
    fi;
    
    sets := List(A, x -> [x]);

    for i in [1..c-1] do
        newsets := [];
        for set in sets do
            for x in A do
                Add(newsets, Set(Union(set, [x])));
            od;
        od;
        sets := Set(newsets);    
    od;
    
    sets := Filtered(sets, x -> Size(x) = c);
    
    return sets;
end;



### DESC: Given a rack Q, returns a minimal-size generating subset of Q.
### STATUS: WORKING
### NOTES: Checks subsets of increasing size until a generating set (whose subrack is the whole Q) is found.

minimalSetOfGenerators := function(Q)

    local i, set, sets, n, S;
    
    n := Size(Q);
    
    for i in [2..n] do
        sets := powerSetWithCardinality([1..n], i);
        
        for set in sets do
            S := subrackGeneratedBy(Q, set);
            if Size(S) = n then
                return set;
            fi;
        od;
    od;
    
end;
